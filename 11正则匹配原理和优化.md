DFA：确定性有穷自动机 Deterministic finite automaton   
NFA：非确定性有穷自动机 Non-deterministic finite automaton

**DFA 工作机制：**   
先看文本，再看正则，以文本为主导。   
速度更快，字符串只看一遍，不会发生回溯。   
执行时间一般是线性，可以确保匹配到最长字符串。   
没有反向引用功能、不支持捕获子组。

**NFA 工作机制：**   
先看正则，再看文本，以正则为主导。   
由于是以正则为主导，反复测试字符串，所以字符串中的同一部分，有可能被反复测试多次。   
引擎实际使用的是贪心匹配回溯算法实现，最坏的情况执行速度非常慢，可能有性能问题。   

**POSIX NFA:**   
应用场景较少，主要使用在 Unix/Linux 某些工具上，不同于传统 NFA，POSIX NFA 在只找到可能的最长匹配之前会继续回溯，尽可能找到最长，如果分支一样长，以最左边为准(The Longest Leftmost),速度比传统 NFA 更慢。   

**回溯：**   
回溯是 NFA 引擎特有的，且只有出现量词或多选分支结构时，才有可能发生回溯。   
需要谨慎使用 `.*`, 因为正则默认贪婪匹配，会吃掉整个字符串，在依次回吐。

**测试性能的方法**
1. 使用 `ipython timeit`
```python
In [1]: import re
In [2]: x = '-' * 1000000 + 'abc'
In [3]: timeit re.search('abc', x)
# 332 µs ± 4.51 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
```
2. 使用 regex101.com

**优化建议**
1. 提前编译好正则`re.compile`，可以不用在每次使用时反复构造自动机。
2. 尽量精确的表示匹配范围和内容，比如如果我们想要提取引号中的内容，使用 `[^"]+` 或者 `.+?` 非贪婪方式。  
3. 提取公共部分:   
   `abcd|abxy` 优化为 `ab(cd|xy)`    
   `this|that` 优化为 `th(?:is|at)`
   `(^this|^that) is` 优化为 `^th(is|at) is`
4. 出现概率大的放左边，`\.(?:com|net)\b`
5. 不需要保存的子组使用 `?:` 剔除，子组会降低正则匹配性能。
6. 警惕嵌套子组重复，匹配次数会指数级增长，比如 `(.*)*`
7. 避免不同分支重复匹配。

**练习**   
由小写字母或数字组成的字符串，单第一个字符必须是小写字母   
文本：a12   
正则：`^(?=[a-z])[a-z0-9]+$`   
匹配过程如下：   
1. 由元字符 `^` 取得控制权，从 0 位置开始匹配，匹配成功。
2. 环视 `(?=[a-z])` 取得控制权，要求它所在位置的右侧必须是小写字母，由于零宽度子表达式不互斥，所以也从 0 位置尝试匹配， 0 位置右侧为字符 a ，匹配成功。
3. `[a-z0-9]+` 取得控制权，由于环视只匹配，但是不保存匹配内容，所以也是从 0 位置开始匹配，首先匹配 a 成功，接下来匹配 1 2 也成功，来到位置3，位置3右侧无字符。
4. 元字符 `$` 取得控制权，从位置3开始匹配，匹配到结束位置。
5. 正则表达式完成匹配，报告匹配结果为 a12，开始位置 0，结束位置 3。
